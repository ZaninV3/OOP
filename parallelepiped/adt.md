# ADT parallelepiped
## Данные
Данный класс представляет собой набор свойств и ряд методов работы для формирования геометрической фигуры параллелепипед.
<!--
  * Была идея сделать по координатам каждой точки, то это довольно проблематично, да и этому работать с ними будет тяжелее. Лучше не делать, так как это в дальнейшем, в случае если С.В. потребует это реализовать, то можно это сделать через геттеры. То есть просчитывать на основании углов и длин ребер, и + добавить координаты смещения, через которые можно будет перемещать параллелепипед в пространстве.
  * Также ранее я хотел использовать height вместо текущего side_line, но идея быстро отпала, т к будут неточности при построении ромбоэдра (параллелепипед, в котором все грани -- ромбы). Поскольку хочется добавить функцию определия вида параллелепипеда.
-->

>![Прямоугольный параллелепипед с точками _A_, _B_, _C_, _D_, _A1_, _B1_, _C1_ и _D1_](https://www.calc.ru/imgs/articles/985-a210c9cdf0d107a8e1d3919be775849e.png)
>
>По умолчанию создается некоторая точка в пространстве, на которой лежат точки _A_, _B_, _C_, _D_, _A1_, _B1_, _C1_ и _D1_. То есть расстояние между этими точками равна 0. В ходе расширения без изменения углов >редполагается, что формируется прямоугольный параллелепипед (все грани являются прямоугольниками).
>
>В параллелепипеде будут использоваться такие виды СС:
>1. мм. для длин ребер;
>2. гр. для углов;

Есть следующие переменные:
* **unsigned float ab_line** - Расстояние между точками _A_ и _B_ (=> и между _C_ и _D_ и аналогично для верхней грани соответственно). Измеряется в мм. По умолчанию значение равно 0;
* **unsigned float bc_line** - Расстояние между точками _B_ и _С_ (аналогично для **ab**). По умолчанию значение равно 0 мм.;
* **unsigned float side_line** - Длина бокового ребра. По умолчанию значение равно 0 мм.;
* **unsigned float bad_angle** - Угол _BAD_ основания _ABCD_. По умолчанию равен 90 гр.;
* **unsigned float a1ad_angle** - Угол _A1AD_. Формирует угол наклона призмы в одно направление. По умолчанию равен 90 гр.;
* **unsigned float a1ab_angle** - Угол _A1AB_. Подобно **a1ad_angle** формирует угол в другое направление. По умолчанию равен 90 гр.;
## Конструкторы
* ### Конструктор 1
  * Вход: -
  * Процесс: Инициализация экземпляра со значениями по умолчанию.
* ### Конструктор 2
  * Вход: **pab, pbc, pside_line, pbad_angle, pa1ad_angle, pa1ab_angle**.
  * Предусловия: Проверка, что введенные метрические значения >= 0 и 0 < **pbad_angle, pa1ad_angle, pa1ab_angle** < 180;
  * Процесс: Инициализация экземпляра со значениями, которые указал пользователь. Если пользователь ввел некоторое значение некорректно, то значению присваивается значение по умолчанию.
## Операции
* ### **getLineAB**
  * Вход: -
  * Выход: **unsigned float ab**
* ### **getLineBC**
  * Вход: -
  * Выход: **unsigned float bc**
* ### **getLineSide**
  * Вход: -
  * Выход: **unsigned float side_line**
* ### **getAngleBAD**
  * Вход: -
  * Выход: **unsigned float bad_angle**
* ### **getAnlgeA1AD**
  * Вход: -
  * Выход: **unsigned float a1ad_angle**
* ### **getAngleA1AB**
  * Вход: -
  * Выход: **unsigned float a1ab_angle**
----
* ### **getType**
  * Вход: -
  * Процесс: Если все ребра равны и все углы равны 90 гр., то это _куб_. Если только все ребра равны, то это _ромбоэдр_. Если только все углы равны 90 гр., то это _прямоугольный параллелепипед_. Если только **a1ab_angle** и **a1ad_angle** прямые, то это _прямой параллелепипед_. В остальных случаях это _наклонный параллелепипед_ (произвольный).
  * Выход: текст, какого типа является параллелепипед
* ### **getSideAndBaseDiagonalAngle**<!-- Вот это формула -- главный кошмар при написании этой ADT, поэтому не хочу ничего здесь объяснять. Просто скажу, что я страдал, когда ее выводил... -->
  * Вход: -
  * Процесс: $x = (arccos((AB^2 + AC^2 - BC^2)/(2 * AB * AC)) / BAD) * (A1AD - A1AB) + A1AB$, где:
    * _AC_ = **getBaseFirstDiagonal**
  * Выход: $x$
----
* ### **getBaseFirstDiagonal**<!-- Формулы нахождения диагоналей на гранях были найдены в Интернете -->
  * Вход: -
  * Процесс: $D = \sqrt{AB^2 + BC^2 - 2 * AB * BC * cos{ABC}}$
  * Выход: $D$
* ### **getBaseSecondDiagonal**
  * Вход: -
  * Процесс: $D = \sqrt{AB^2 + BC^2 + 2 * AB * BC * cos{ABC}}$
  * Выход: $D$
* ### **getFrontFirstDiagonal**
  * Вход: -
  * Процесс: $D = \sqrt{AA1^2 + AD^2 - 2 * AA1 * AD * cos{A1AD}}$
  * Выход: $D$
* ### **getFrontSecondDiagonal**
  * Вход: -
  * Процесс: $D = \sqrt{AA1^2 + AD^2 + 2 * AA1 * AD * cos{A1AD}}$
  * Выход: $D$
* ### **getSideFirstDiagonal**
  * Вход: -
  * Процесс: $D = \sqrt{AA1^2 + AB^2 - 2 * AA1 * AB * cos{A1AB}}$
  * Выход: $D$
* ### **getSideSecondDiagonal**
  * Вход: -
  * Процесс: $D = \sqrt{AA1^2 + AB^2 + 2 * AA1 * AB * cos{A1AB}}$
  * Выход: $D$
----
* ### **getBaseFirstHeight**<!-- Та же песня, что и с диагоналями, кроме getMainHeight... -->
  * Вход: -
  * Процесс: $H = AB * sin{BAD}$
  * Выход: $H$
* ### **getBaseSecondHeight**
  * Вход: -
  * Процесс: $H = BC * sin(180 - BAD)$
  * Выход: $H$
* ### **getFrontFirstHeight**
  * Вход: -
  * Процесс: $H = AA1 * sin(180 - A1AD)$
  * Выход: $H$
* ### **getFrontSecondHeight**
  * Вход: -
  * Процесс: $H = AD * sin(180 - A1AD)$
  * Выход: $H$
* ### **getSideFirstHeight**
  * Вход: -
  * Процесс: $H = AA1 * sin(180 - A1AB)$
  * Выход: $H$
* ### **getSideSecondHeight**
  * Вход: -
  * Процесс: $H = AB * sin(180 - A1AB)$
  * Выход: $H$
* ### **getMainHeight**
  * Вход: -
  * Процесс: $H = AA1 * sin{A1AC}$, где:
    * _A1AC_ = **getSideAndBaseDiagonalAngle**
  * Выход: $H$
----
* ### **getFrontSquare**<!-- Ну а на площадях комментарии излишни -->
  * Вход: -
  * Процесс: $S = H1 * AD$, где:
    * _H1_ = **getFrontFirstHeight**
  * Выход: $S$
* ### **getSideSquare**
  * Вход: -
  * Процесс: $S = H1 * AB$, где:
    * _H1_ = **getSideFirstHeight**
  * Выход: $S$
* ### **getBaseSquare**
  * Вход: -
  * Процесс: $S = H1 * BC$, где:
    * _H1_ = **getBaseFirstHeight**
  * Выход: $S$
* ### **getFrontsAndSidesSquare**
  * Вход: -
  * Процесс: $S = 2 * S1 + 2 * S2$, где:
    * _S1_ = **getFrontSquare**
    * _S2_ = **getSideSquare**
  * Выход: $S$
* ### **getFullSquare**
  * Вход: -
  * Процесс: $S = 2(H1 * BC) + S1$, где:
    * _H1_ = **getBaseFirstHeight**
    * _S1_ = **getSideSquare**
  * Выход: $S$
----
* ### **getVolume**
  * Вход: -
  * Предусловие: **ab_line, bc_line, side_line** != 0
  * Процесс: $V = H * S$, где:
    * _H_ = **getSideAndBaseDiagonalAngle**
    * _S_ = **getBaseSquare**
  * Выход $V$
----
* ### **setLineAB**
  * Вход: **pab**
  * Предусловие: **pab** > 0
  * Процесс: **ab = pab**
  * Выход: **true**, если предусловие было соблюдено
* ### **setLineBC**
  * Вход: **pbc**
  * Предусловие: **pbc** > 0
  * Процесс: **bc = pbc**
  * Выход: **true**, если предусловие было соблюдено
* ### **setLineSide**
  * Вход: **pside_line**
  * Предусловие: **pside_line** > 0
  * Процесс: **side_line = pside_line**
  * Выход: **true**, если предусловие было соблюдено
* ### **setAngleBAD**
  * Вход: **pbad_angle**
  * Предусловие: 0 < **pbad_angle** < 180
  * Процесс: **bad_angle = pbad_angle**
  * Выход: **true**, если предусловие было соблюдено
* ### **setAngleA1AD**
  * Вход: **pa1ad_angle**
  * Предусловие: 0 < **pa1ad_angle** < 180
  * Процесс: **a1ad_angle = pa1ad_angle**
  * Выход: **true**, если предусловие было соблюдено
* ### **setAngleA1AB**
  * Вход: **pa1ab_angle**
  * Предусловие: 0 < **pa1ab_angle** < 180
  * Процесс: **a1ab_angle = pa1ab_angle**
  * Выход: **true**, если предусловие было соблюдено
# Конец ADT
