# Список готовых конспектов
- [x] Значения аргументов функций по умолчанию
- [ ] Ключевое слово `static`
- [ ] Отчёт по __Git__
- [ ] Этапы компиляции программы на __C++__
- [x] Синонимы типов с помощью `using` и `typedef`
- [ ] Компиляция в командной строке
- [ ] Умные указатели. `unique_ptr`, функция `make_unique`
- [ ] Совместный цикл
# Значения агрументов функций по умолчанию
__Аргумент по умолчанию__ – это такой аргумент функции, который программист __может не указывать при вызове__ функции. Аргумент по умолчанию добавляется компилятором автоматически.

Например, ниже объявляется функция `f()`, имеющая аргументом целую переменную, значением которой по умолчанию является величина `1`:
```
void foo(int i = 1) {
  // Тело функции
}
```
Теперь функция `foo()` может вызываться двумя способами, как показано ниже:
```
foo(10);  // явная передача значения
foo();  // функция использует значение по умолчанию
```
В первом случае аргументу `i` будет присвоено значение `10`. Во втором случае `i` получит значение по умолчанию, равное `1`.
__При использовании__ аргументов по умолчанию __обратите внимание__ на следующие моменты:
* Аргументы по умолчанию используются только в вызовах функции, в которых опущены заключительные __аргументы__ - они __должны быть__ последними аргументами. Поэтому следующий код недопустим:
  ```
  int print( double dvalue = 0.0, int prec );
  ```
* __Переопределение__ аргумента по умолчанию в последующих объявлениях __не допускается__, даже если переопределение совпадает с оригиналом. Поэтому приведенный ниже код вызывает ошибку:
  ```
    // Prototype for print function.
  int print( double dvalue, int prec = 2 );
  
  // ...
  
  // Definition for print function.
  int print( double dvalue, int prec = 2 ) {
  // ...
  }
  ```
* __В последующих определениях допускается__ добавлять дополнительные аргументы по умолчанию.
* Аргументы по умолчанию могут указываться для указателей на функции.
* Помимо функций аргументы по умолчанию также допускается использовать в конструкторах и методах класса. Пример:
  ```
  // класс, который описывает круг
  class Circle {
    // внутренние переменные класса
    double x, y, radius;
    
    public:
      // конструктор, который принимает аргументы по умолчанию
      Circle(double nx=10, double ny = 10, double nradius = 1) {
        x = nx;
        y = ny;
        radius = nradius;
      }
      
      // Методы доступа
      // чтение значений x, y, r
      double GetX(void) { return x; }
      double GetY(void) { return y; }
      double GetR(void) { return radius; }
      
      // метод, который содержит аргументы по умолчанию
      void SetXYR(double nx=0, double ny=0, double nradius=1) {
        x = nx;
        y = ny;
        radius = nradius;
      }
  };
  ```
Во время __объявления__ функции, аргументы по умолчанию __задаются только один раз__. Здесь возможны два случая. Первый, если функция имеет __прототип и реализацию__. Второй случай, если функция не имеет прототипа, а имеет __только реализацию__.
Пример:
```
// объявление аргументов по умолчанию в прототипе функции
double GetAreaCircle(double r = 1);

// функция не имеет прототипа, поэтому аргумент по умолчанию задается непосредственно в реализации
double GetVolumeSphere(double r = 1){
  return 4.0/3 * Pi*r*r*r;
}

// реализация функции - аргументы по умолчанию уже заданы в прототипе
double GetAreaCircle(double r) {
  return Pi * r * r;
}
```
__Преимущества__ использования аргументов по умолчанию:
* __Сокращается листинг__ программного кода за счет избегания написания лишних функций, которые выполняют ту же работу только с другими значениями аргументов;
* Обеспечивается __простой, естественный и эффективный стиль__ программирования;
* В некоторых случаях аргументы по умолчанию есть сокращенной формой перегрузки функции. Это, в свою очередь улучшает читабельность программного кода и __упрощает вызов__ функции.

Источники:
* https://www.bestprog.net/ru/2018/07/30/functions-arguments-by-default-in-functions_ru/
* https://www.c-cpp.ru/books/znacheniya-argumentov-funkcii-po-umolchaniyu
* https://learn.microsoft.com/ru-ru/cpp/cpp/default-arguments?view=msvc-170

# Ключевое слово `static`
`static` — это ключевое слово в __C++__, используемое для __придания__ элементу __особых характеристик__. Для статических элементов __выделение__ памяти происходит __только один__ раз и существуют эти элементы __до завершения__ программы. Хранятся все эти элементы не в `heap` и не на `stack`, а в __специальных сегментах__ памяти, которые называются `.data` и `.bss` (зависит от того инициализированы статические данные или нет). На картинке ниже показан типичный макет программной памяти:

<p align="center">
  <img src="https://github.com/ZaninV3/OOP/blob/main/pictures/programs_memory.png">
</p>

## Статические переменные внутри функции

__Статические переменные__ при использовании внутри функции __инициализируются__ только __один__ раз, а затем они сохраняют свое значение. Эти статические переменные __хранятся__ в __статической__ области памяти (`.data` или `.bss`), а не в стеке, что -__позволяет хранить__ и __использовать__ значение переменной на протяжении __всей жизни__ программы. Давайте рассмотрим две почти одинаковые программы и их поведение.

Первая программа:
```
#include <iostream>

void counter() {
  static int count = 0;  // строка 3
  std::cout << count++;
}

int main() {
  for (int i = 0; i < 10; ++i) {
    counter();
  }
}
```
Вторая программа:
```
#include <iostream>

void counter() {
  int count = 0;  // строка 3
  std::cout << count++;
}

int main() {
  for (int i = 0; i < 10; ++i) {
    counter();
  }
}
```
По итогу обе __программы__ выведут __разный__ результат: `0123456789` для первой и `0000000000` для второй. Если __не использовать__ `static` в строке `3`, выделение памяти и __инициализация__ переменной `count` происходит __при каждом вызове__ функции `counter()`, и __уничтожается каждый раз__, когда функция завершается. Но если мы __сделаем__ переменную __статической__, после инициализации (при первом вызове функции `counter()`) __область видимости__ `count` будет до __конца функции__ `main()`, и переменная будет __хранить__ свое значение __между вызовами__ функции `counter()`.

## Статические объекты класса

Второе использование `static` — __внутри__ определения __класса__. Хотя __большинство__ переменных, объявленных внутри класса, могут иметь __разное значение__ в __каждом экземпляре__ класса, __статические__ поля класса будут иметь __то же значение для всех__ экземпляров данного класса и даже __не обязательно создавать__ экземпляр этого класса. Полезно представить себе, что статические переменные класса содержат информацию, необходимую для создания новых объектов. Например, если вы хотите __пронумеровать экземпляры__ класса, можно использовать статическую переменную __для отслеживания последнего__ используемого номера.

Пусть есть класс Base имеющий только конструктор и деструктор. В качестве примера будем работать с `void foo()`.
```
#include <iostream>

class Base {
  public:
    Base() {
      std::cout << "Constructor" << std::endl;
    }

    ~Base() {
      std::cout << "Destructor" << std::endl;
    }
};

void foo();  // Объявление функции

int main() {
  foo();
  std::cout << "End of main()" << std::endl;
}
```
Реализация функции `foo()` в первом случае:
```
void foo() {
  Base obj;
}
```
Во втором случае:
```
void foo() {
  static Base obj;
}
```
В первом случае программа выведет:
```
Constructor
Destructor
End of main()
```
Во втором:
```
Constructor
End of main()
Destructor
```
Из-за того, что объект __статический__, деструктор __вызывается__ не при выходе из функции `foo()`, а только __при завершении__ программы, т.к. статический объект __разрушается при завершении__ программы. Если мы уберем `static` при создании переменной в функции `foo()`, то разрушение объекта будет происходить в конце каждого вызова функции.

__Важно__ отметить, что хорошим тоном при использовании статических переменных класса является __использование__ `class_name::х`, а не `instance_of_class.x`. Это __помогает напомнить__ программисту, что статические переменные __не принадлежат к одному__ экземпляру класса, и что вам __не обязательно создавать__ экземпляр этого класса. Как вы уже, наверное, заметили, для доступа к `static` можно использовать оператор области видимости, `::`, когда вы обращаетесь к нему через имя класса.

## Статические функции

Статические функции пришли в __С++__ из __С__. По умолчанию все функции в __С__ глобальные и, если вы __захотите создать__ две функции с __одинаковым именем__ в двух разных `.c`(`.cpp`) файлах одного проекта, то получите __ошибку__ о том, что данная функция __уже определена__ (`fatal error LNK1169: one or more multiply defined symbols found`). Для того чтобы исправить данную проблему, одну из функций необходимо __объявлять статической__. Вы говорите компилятору, что доступ к статическим функциям __ограничен файлом__, в котором они объявлены. Таким образом, используя `static` для функции, мы можем ограничить область видимости этой функции, и данная функция не будет видна в других файлах, если, конечно, это не заголовочный файл (`.h`).

## Статические функции-члены класса (методы)

Статическую функцию-член вы можете использовать без создания объекта класса. Доступ к статическим функциям осуществляется с использованием имени класса и оператора разрешения области видимости (`::`). При использовании статической функции-члена есть ограничения, такие как:
1.	Внутри функции обращаться можно только к статическим членам данных, другим статическим функциям-членам и любым другим функциям извне класса.
2.	Статические функции-члены имеют область видимости класса, в котором они находятся.
3.	Вы не имеете доступа к указателю `this` класса, потому что мы не создаем никакого объекта для вызова этой функции.

Источники:
* https://habr.com/ru/articles/527044/
* http://cppstudio.com/post/3298/

# Отчёт по Git

Во время разработки требуется хранить как минимум 2 версии исходного кода программы: версию находящийся в активной разработке и последнюю гарантировано рабочую версию.

Копия программы нужна чтобы __продемонстрировать__ заказчику или чтобы вернуться к ней, если с текущей версией случится что-нибудь __плохое__.

Решить эту проблемы, автоматизировать рутинные операции призвана __система управления версиями__.

__Система управления версиями__ (Version Control System, VCS) – программное обеспечение для облегчения работы с изменяющейся информацией.

`Git` - один из видов __VCS__.

В целом VCS можно разделить таким образом:
* __Локальные__ - все файлы хранятся только __в вашей ОС__, например, разложены по папкам с версиями.
* __Централизованные__ - проект хранится __на сервере__, а ваша рабочая версия включает только текущий набор файлов.
* __Распределенные__ - копии проекта (и вся информация о версиях) располагаются __не только на сервере__, __но и на__ нескольких __клиентских машинах__, чтобы обеспечить устойчивость к отказу сервера.

__Репозиторием__ называют хранилище вашего кода и историю его изменений. `Git` работает __локально__ и все ваши репозитории хранятся в определенных папках на жестком диске.

__Коммит__ - это способ __сохранения изменений в коде__. Каждый `commit` содержит информацию о том, __что было изменено__ в коде __и кем__ были внесены эти изменения. Они позволяют разработчикам отслеживать изменения в своем (или чужом) коде и возвращаться к предыдущим версиям, если это необходимо.

__Ветка__ - это __набор__ `commit`, которые идут __друг за другом__. У ветки __есть название__, основную ветку чаще всего называют `master`. Если говорить простыми словами, то ветка `master` — это наш проект.

## Навигация через Git Bash

* `clear` — Очистить консоль
* `pwd` — Показать текущий каталог
* `ls` - Показать файлы в данной папке, включая и скрытые
* `ls -f` — Показать файлы в данной папке, кроме скрытых
* `cd c:/` — Перейти в конкретный каталог
* `cd` - — Вернуться назад
* `cd ..` — Выйти на 1 уровень вверх
* `cd ../..` — Выйти на 2 уровня вверх
* `mkdir` — Создать папку
* `cd !$` — Перейти в только что созданную папку
* `mkdir -p {app1,app2}` — Создать сразу несколько папок
* `mkdir -p app/{css,js}` — Создать сразу несколько вложенных папок
* `touch index.html — Создать файл index.html`
* `touch app/{css/main.css,js/main.js,index.html}` — Создать сразу несколько файлов, никаких лишних пробелов быть не должно
* `touch` — позволяет создавать файлы
* `rm test` — Удалить пустую папку `test`
* `rm -r test` — Удалить папку `test` с файлами внутри неё
* `mv app1/*.* app2` — Переместить все файлы из папки `app1` в папку `app2`

## Работа с репозиторием

* `git init` – создание репозитория в текущей директории
* `git status` – проверка статуса директории (если репозитория нет, то будет выведено сообщение)
* `git add <название_файла>` – добавление файла в отслеживаемые (Для того, чтобы добавить все файлы сразу то в место файла нужно поставить точку или `--all`. Просмотреть можно через `git status`)
* `git clone <cсылка> <новое_название>` - клонирование существующего репозитория
* `get fetch <названия репозитория>` - копирование изменений удаленного репозитория
* `git commit -m “описание”` – создание коммита
* `git ls-files` – просмотр отслеживаемых файлов
* `git log` – просмотр всех коммитов
* `git diff` – показывает разницу между текущим состоянием файлов и предыдущим коммитом
* `git diff <исходная_ветка> <целевая_ветка>` - показывает разницу между двух веток
* `git branch <название_ветки>` – создание новой ветки (если не указывать название ветки, то будет отображен список всех веток)
* `git branch -d <название_ветки>` - удаление ветки
* `git checkout <название_ветки>` – переключение между ветками
* `git pull origin master` – обновление локальной ветки `master`
* `git merge <название_ветки>` - слияние ветки
* `git push origin master` – отправка изменений ветки `master` на удаленный репозиторий (нужно обязательно находиться на этой ветке)
* `git clone <адрес_репозитория>` - клонирование существующего репозитория через ссылку
* `git help` - справочник

Источники:
* https://github.com/VetrovSV/Programming/blob/master/git_lec.pdf
* https://habr.com/ru/articles/541258/
* https://selectel.ru/blog/tutorials/git-setup-and-common-commands/
* https://git-scm.com/book/ru/v2/%D0%9E%D1%81%D0%BD%D0%BE%D0%B2%D1%8B-Git-%D0%A1%D0%BE%D0%B7%D0%B4%D0%B0%D0%BD%D0%B8%D0%B5-Git-%D1%80%D0%B5%D0%BF%D0%BE%D0%B7%D0%B8%D1%82%D0%BE%D1%80%D0%B8%D1%8F
* https://gist.github.com/sasstr/03d819bd98272ae261dd29ef731e9a6f
* https://www.learnqa.ru/tpost/z1k65h4um1-chto-takoe-commit-v-git
* https://habr.com/ru/articles/542616/
* https://docs.github.com/ru/get-started/using-git/getting-changes-from-a-remote-repository
