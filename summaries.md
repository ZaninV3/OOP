# Список готовых конспектов
- [x] Значения аргументов функций по умолчанию
- [ ] Ключевое слово `static`
- [ ] Отчёт по __Git__
- [ ] Этапы компиляции программы на __C++__
- [x] Синонимы типов с помощью `using` и `typedef`
- [ ] Компиляция в командной строке
- [ ] Умные указатели. `unique_ptr`, функция `make_unique`
- [ ] Совместный цикл
# Значения агрументов функций по умолчанию
__Аргумент по умолчанию__ – это такой аргумент функции, который программист __может не указывать при вызове__ функции. Аргумент по умолчанию добавляется компилятором автоматически.

Например, ниже объявляется функция `f()`, имеющая аргументом целую переменную, значением которой по умолчанию является величина `1`:
```
void foo(int i = 1) {
  // Тело функции
}
```
Теперь функция `foo()` может вызываться двумя способами, как показано ниже:
```
foo(10);  // явная передача значения
foo();  // функция использует значение по умолчанию
```
В первом случае аргументу `i` будет присвоено значение `10`. Во втором случае `i` получит значение по умолчанию, равное `1`.
__При использовании__ аргументов по умолчанию __обратите внимание__ на следующие моменты:
* Аргументы по умолчанию используются только в вызовах функции, в которых опущены заключительные __аргументы__ - они __должны быть__ последними аргументами. Поэтому следующий код недопустим:
  ```
  int print( double dvalue = 0.0, int prec );
  ```
* __Переопределение__ аргумента по умолчанию в последующих объявлениях __не допускается__, даже если переопределение совпадает с оригиналом. Поэтому приведенный ниже код вызывает ошибку:
  ```
    // Prototype for print function.
  int print( double dvalue, int prec = 2 );
  
  // ...
  
  // Definition for print function.
  int print( double dvalue, int prec = 2 ) {
  // ...
  }
  ```
* __В последующих определениях допускается__ добавлять дополнительные аргументы по умолчанию.
* Аргументы по умолчанию могут указываться для указателей на функции.
* Помимо функций аргументы по умолчанию также допускается использовать в конструкторах и методах класса. Пример:
  ```
  // класс, который описывает круг
  class Circle {
    // внутренние переменные класса
    double x, y, radius;
    
    public:
      // конструктор, который принимает аргументы по умолчанию
      Circle(double nx=10, double ny = 10, double nradius = 1) {
        x = nx;
        y = ny;
        radius = nradius;
      }
      
      // Методы доступа
      // чтение значений x, y, r
      double GetX(void) { return x; }
      double GetY(void) { return y; }
      double GetR(void) { return radius; }
      
      // метод, который содержит аргументы по умолчанию
      void SetXYR(double nx=0, double ny=0, double nradius=1) {
        x = nx;
        y = ny;
        radius = nradius;
      }
  };
  ```
Во время __объявления__ функции, аргументы по умолчанию __задаются только один раз__. Здесь возможны два случая. Первый, если функция имеет __прототип и реализацию__. Второй случай, если функция не имеет прототипа, а имеет __только реализацию__.
Пример:
```
// объявление аргументов по умолчанию в прототипе функции
double GetAreaCircle(double r = 1);

// функция не имеет прототипа, поэтому аргумент по умолчанию задается непосредственно в реализации
double GetVolumeSphere(double r = 1){
  return 4.0/3 * Pi*r*r*r;
}

// реализация функции - аргументы по умолчанию уже заданы в прототипе
double GetAreaCircle(double r) {
  return Pi * r * r;
}
```
__Преимущества__ использования аргументов по умолчанию:
* __Сокращается листинг__ программного кода за счет избегания написания лишних функций, которые выполняют ту же работу только с другими значениями аргументов;
* Обеспечивается __простой, естественный и эффективный стиль__ программирования;
* В некоторых случаях аргументы по умолчанию есть сокращенной формой перегрузки функции. Это, в свою очередь улучшает читабельность программного кода и __упрощает вызов__ функции.

Источники:
* https://www.bestprog.net/ru/2018/07/30/functions-arguments-by-default-in-functions_ru/
* https://www.c-cpp.ru/books/znacheniya-argumentov-funkcii-po-umolchaniyu
* https://learn.microsoft.com/ru-ru/cpp/cpp/default-arguments?view=msvc-170

# Ключевое слово `static`
`static` — это ключевое слово в __C++__, используемое для __придания__ элементу __особых характеристик__. Для статических элементов __выделение__ памяти происходит __только один__ раз и существуют эти элементы __до завершения__ программы. Хранятся все эти элементы не в `heap` и не на `stack`, а в __специальных сегментах__ памяти, которые называются `.data` и `.bss` (зависит от того инициализированы статические данные или нет). На картинке ниже показан типичный макет программной памяти:

<p align="center">
  <img src="https://github.com/ZaninV3/OOP/blob/main/pictures/programs_memory.png">
</p>

## Статические переменные внутри функции

__Статические переменные__ при использовании внутри функции __инициализируются__ только __один__ раз, а затем они сохраняют свое значение. Эти статические переменные __хранятся__ в __статической__ области памяти (`.data` или `.bss`), а не в стеке, что -__позволяет хранить__ и __использовать__ значение переменной на протяжении __всей жизни__ программы. Давайте рассмотрим две почти одинаковые программы и их поведение.

Первая программа:
```
#include <iostream>

void counter() {
  static int count = 0;  // строка 3
  std::cout << count++;
}

int main() {
  for (int i = 0; i < 10; ++i) {
    counter();
  }
}
```
Вторая программа:
```
#include <iostream>

void counter() {
  int count = 0;  // строка 3
  std::cout << count++;
}

int main() {
  for (int i = 0; i < 10; ++i) {
    counter();
  }
}
```
По итогу обе __программы__ выведут __разный__ результат: `0123456789` для первой и `0000000000` для второй. Если __не использовать__ `static` в строке `3`, выделение памяти и __инициализация__ переменной `count` происходит __при каждом вызове__ функции `counter()`, и __уничтожается каждый раз__, когда функция завершается. Но если мы __сделаем__ переменную __статической__, после инициализации (при первом вызове функции `counter()`) __область видимости__ `count` будет до __конца функции__ `main()`, и переменная будет __хранить__ свое значение __между вызовами__ функции `counter()`.

## Статические объекты класса

Второе использование `static` — __внутри__ определения __класса__. Хотя __большинство__ переменных, объявленных внутри класса, могут иметь __разное значение__ в __каждом экземпляре__ класса, __статические__ поля класса будут иметь __то же значение для всех__ экземпляров данного класса и даже __не обязательно создавать__ экземпляр этого класса. Полезно представить себе, что статические переменные класса содержат информацию, необходимую для создания новых объектов. Например, если вы хотите __пронумеровать экземпляры__ класса, можно использовать статическую переменную __для отслеживания последнего__ используемого номера.

Пусть есть класс Base имеющий только конструктор и деструктор. В качестве примера будем работать с `void foo()`.
```
#include <iostream>

class Base {
  public:
    Base() {
      std::cout << "Constructor" << std::endl;
    }

    ~Base() {
      std::cout << "Destructor" << std::endl;
    }
};

void foo();  // Объявление функции

int main() {
  foo();
  std::cout << "End of main()" << std::endl;
}
```
Реализация функции `foo()` в первом случае:
```
void foo() {
  Base obj;
}
```
Во втором случае:
```
void foo() {
  static Base obj;
}
```
В первом случае программа выведет:
```
Constructor
Destructor
End of main()
```
Во втором:
```
Constructor
End of main()
Destructor
```
Из-за того, что объект __статический__, деструктор __вызывается__ не при выходе из функции `foo()`, а только __при завершении__ программы, т.к. статический объект __разрушается при завершении__ программы. Если мы уберем `static` при создании переменной в функции `foo()`, то разрушение объекта будет происходить в конце каждого вызова функции.

__Важно__ отметить, что хорошим тоном при использовании статических переменных класса является __использование__ `class_name::х`, а не `instance_of_class.x`. Это __помогает напомнить__ программисту, что статические переменные __не принадлежат к одному__ экземпляру класса, и что вам __не обязательно создавать__ экземпляр этого класса. Как вы уже, наверное, заметили, для доступа к `static` можно использовать оператор области видимости, `::`, когда вы обращаетесь к нему через имя класса.

## Статические функции

Статические функции пришли в __С++__ из __С__. По умолчанию все функции в __С__ глобальные и, если вы __захотите создать__ две функции с __одинаковым именем__ в двух разных `.c`(`.cpp`) файлах одного проекта, то получите __ошибку__ о том, что данная функция __уже определена__ (`fatal error LNK1169: one or more multiply defined symbols found`). Для того чтобы исправить данную проблему, одну из функций необходимо __объявлять статической__. Вы говорите компилятору, что доступ к статическим функциям __ограничен файлом__, в котором они объявлены. Таким образом, используя `static` для функции, мы можем ограничить область видимости этой функции, и данная функция не будет видна в других файлах, если, конечно, это не заголовочный файл (`.h`).

## Статические функции-члены класса (методы)

Статическую функцию-член вы можете использовать без создания объекта класса. Доступ к статическим функциям осуществляется с использованием имени класса и оператора разрешения области видимости (`::`). При использовании статической функции-члена есть ограничения, такие как:
1.	Внутри функции обращаться можно только к статическим членам данных, другим статическим функциям-членам и любым другим функциям извне класса.
2.	Статические функции-члены имеют область видимости класса, в котором они находятся.
3.	Вы не имеете доступа к указателю `this` класса, потому что мы не создаем никакого объекта для вызова этой функции.

Источники:
* https://habr.com/ru/articles/527044/
* http://cppstudio.com/post/3298/
